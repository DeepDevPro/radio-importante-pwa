# GitHub Actions - Deploy Completo (Frontend + Backend)
name: 🚀 Deploy Complete Stack

on:
  push:
    branches: [main]
  workflow_dispatch: # Permite trigger manual
    inputs:
      deploy_backend:
        description: 'Deploy backend também?'
        required: false
        default: 'true'
        type: boolean
      deploy_frontend:
        description: 'Deploy frontend também?'
        required: false
        default: 'true'
        type: boolean

jobs:
  changes:
    name: 🔍 Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
    steps:
    - uses: actions/checkout@v4
    - uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          backend:
            - 'backend/**'
          frontend:
            - 'src/**'
            - 'public/**'
            - 'index.html'
            - 'package.json'
            - 'vite.config.ts'

  deploy-backend:
    name: 🏗️ Deploy Backend
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.backend == 'true' || github.event.inputs.deploy_backend == 'true'
    defaults:
      run:
        working-directory: ./backend
    outputs:
      backend_url: ${{ steps.get-url.outputs.url }}
        
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
    
    - name: 🟢 Setup Node.js 18
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: './backend/package-lock.json'
        
    - name: 📦 Install dependencies
      run: npm ci
      
    - name: 🔧 Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2
        
    - name: 🛠️ Install EB CLI
      run: pip install awsebcli
        
    - name: 🚀 Deploy to Elastic Beanstalk
      run: |
        if [ ! -d ".elasticbeanstalk" ]; then
          eb init radio-pwa-backend --region us-west-2 --platform node.js
        fi
        
        # Força reinicialização se o environment existe mas não está acessível
        if ! eb status radio-pwa-backend-prod >/dev/null 2>&1; then
          echo "Environment not accessible, removing config and reinitializing..."
          rm -rf .elasticbeanstalk
          eb init radio-pwa-backend --region us-west-2 --platform node.js
        fi
        
        echo "Deploying to environment..."
        # Verifica novamente se o environment está acessível após reinicialização
        if eb status radio-pwa-backend-prod >/dev/null 2>&1; then
          echo "Environment exists and accessible, deploying..."
          eb deploy radio-pwa-backend-prod --timeout 20
        else
          echo "Environment not found or not accessible. Checking if it exists in AWS..."
          # Tenta usar AWS CLI para verificar se o environment existe
          if aws elasticbeanstalk describe-environments --environment-names radio-pwa-backend-prod --region us-west-2 --query 'Environments[0].Status' --output text 2>/dev/null | grep -q "Ready"; then
            echo "Environment exists in AWS but not accessible via EB CLI."
            echo "Creating application version first..."
            
            # Criar versão da aplicação manualmente
            VERSION_LABEL="app-$(date +%y%m%d_%H%M%S)"
            echo "Creating application version: $VERSION_LABEL"
            aws elasticbeanstalk create-application-version \
              --application-name radio-pwa-backend \
              --version-label $VERSION_LABEL \
              --description "Automated deployment $(date)" \
              --source-bundle S3Bucket="elasticbeanstalk-us-west-2-$(aws sts get-caller-identity --query Account --output text)",S3Key="radio-pwa-backend/deploy-package.zip" \
              --region us-west-2 || echo "Version creation failed, trying direct deploy..."
            
            echo "Waiting for application version to be processed..."
            # Wait until version is PROCESSED - with fallback
            TIMEOUT_REACHED=false
            for i in {1..15}; do
              STATUS=$(aws elasticbeanstalk describe-application-versions --application-name radio-pwa-backend --version-labels $VERSION_LABEL --region us-west-2 --query 'ApplicationVersions[0].Status' --output text 2>/dev/null || echo "NOTFOUND")
              echo "Attempt $i: Version status is $STATUS"
              if [ "$STATUS" = "PROCESSED" ]; then
                echo "✅ Application version is ready for deployment"
                break
              elif [ "$STATUS" = "FAILED" ]; then
                echo "❌ Application version processing failed"
                break
              elif [ "$i" -eq 15 ]; then
                echo "⚠️ Timeout reached, proceeding with deployment anyway..."
                TIMEOUT_REACHED=true
                break
              fi
              sleep 3
            done
            
            echo "Deploying version to environment using AWS CLI..."
            if [ "$TIMEOUT_REACHED" = true ]; then
              echo "⚠️ Using direct EB deploy due to timeout..."
              eb deploy radio-pwa-backend-prod --timeout 20 || echo "EB deploy failed"
            else
              aws elasticbeanstalk update-environment \
                --environment-name radio-pwa-backend-prod \
                --version-label $VERSION_LABEL \
                --region us-west-2 || echo "AWS CLI deploy failed, trying EB CLI..."
            fi
            
            echo "Waiting for deployment to complete..."
            aws elasticbeanstalk wait environment-updated --environment-names radio-pwa-backend-prod --region us-west-2
            
            echo "✅ Deployment completed successfully!"
          else
            echo "Creating new environment..."
            eb create radio-pwa-backend-prod --instance-type t3.micro --timeout 20 --envvars NODE_ENV=production,AWS_REGION=us-west-2,S3_BUCKET_NAME=radio-importante-storage
          fi
        fi
        
    - name: 🔍 Get backend URL
      id: get-url
      run: |
        URL=$(eb status radio-pwa-backend-prod | grep "CNAME" | awk '{print $2}')
        echo "url=http://$URL" >> $GITHUB_OUTPUT
        echo "🌐 Backend URL: http://$URL"

  deploy-frontend:
    name: 🎨 Deploy Frontend
    runs-on: ubuntu-latest
    needs: [changes, deploy-backend]
    if: always() && (needs.changes.outputs.frontend == 'true' || github.event.inputs.deploy_frontend == 'true')
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
      
    - name: 🟢 Setup Node.js 18
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: 📦 Install dependencies
      run: npm ci
      
    - name: 🔧 Configure backend URL (if deployed)
      run: |
        if [ -n "${{ needs.deploy-backend.outputs.backend_url }}" ]; then
          echo "Configuring frontend to use backend: ${{ needs.deploy-backend.outputs.backend_url }}"
          # Aqui podemos adicionar lógica para atualizar config do frontend
        fi
      
    - name: 🏗️ Build frontend
      run: npm run build
      
    - name: 🔧 Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2
        
    - name: 🌐 Deploy to S3
      run: |
        aws s3 sync dist/ s3://${{ secrets.S3_BUCKET_NAME }} --delete
        
    - name: 🔄 Invalidate CloudFront (if exists)
      run: |
        if [ -n "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
        fi
      continue-on-error: true

  test-integration:
    name: 🧪 Integration Tests
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: always() && needs.deploy-backend.result == 'success'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
      
    - name: 🧪 Test backend health
      run: |
        BACKEND_URL="${{ needs.deploy-backend.outputs.backend_url }}"
        echo "Testing backend at: $BACKEND_URL"
        
        # Health check
        curl -f "$BACKEND_URL/health"
        
        # API endpoints
        curl -f "$BACKEND_URL/api/upload/status"
        curl -f "$BACKEND_URL/api/catalog"
        
        echo "✅ All backend tests passed!"
        
    - name: 🌐 Test frontend
      run: |
        FRONTEND_URL="https://${{ secrets.S3_BUCKET_NAME }}.s3-website-us-west-2.amazonaws.com"
        echo "Testing frontend at: $FRONTEND_URL"
        
        if curl -f "$FRONTEND_URL" > /dev/null; then
          echo "✅ Frontend is accessible!"
        else
          echo "⚠️ Frontend might still be deploying..."
        fi

  notify:
    name: 📢 Notify Success
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend, test-integration]
    if: always()
    
    steps:
    - name: 📊 Deployment Summary
      run: |
        echo "## 🚀 Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Backend" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.deploy-backend.result }}" == "success" ]; then
          echo "- ✅ **Backend**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
          echo "- 🌐 **URL**: ${{ needs.deploy-backend.outputs.backend_url }}" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ⏭️ **Backend**: Skipped or failed" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Frontend" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.deploy-frontend.result }}" == "success" ]; then
          echo "- ✅ **Frontend**: Deployed successfully" >> $GITHUB_STEP_SUMMARY
          echo "- 🌐 **URL**: https://${{ secrets.S3_BUCKET_NAME }}.s3-website-us-west-2.amazonaws.com" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ⏭️ **Frontend**: Skipped or failed" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Tests" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.test-integration.result }}" == "success" ]; then
          echo "- ✅ **Integration tests**: All passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ⚠️ **Integration tests**: Some issues detected" >> $GITHUB_STEP_SUMMARY
        fi
